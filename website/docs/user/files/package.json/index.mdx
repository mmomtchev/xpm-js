---

title: package.json

date: 2019-07-02 00:36:00 +0300

---

# package.json

## Overview

The **xpm** `package.json` file is
basically the same as the **npm**
[`package.json`](https://docs.npmjs.com/files/package.json),
with some extensions.

The extensions are grouped below the `xpack` object, and may
contain the following definitions:

  - `minimumXpmRequired`
  - `dependencies`
  - `devDependencies`
  - `binaries`
  - `properties`
  - `actions`
  - `buildConfigurations`


## LiquidJS substitutions summary

In addition to the new `xpacks` definitions, another key extension
that comes with **xpm** is the use of substitutions through the
[LiquidJS](https://liquidjs.com) engine. The full Liquid syntax, with
**tags** and **filters**, is supported.

Below is a summary of variables and filters available for substitutions.

For more details, please see the documentation for the
[`xpack/xpm-liquid-ts`](https://xpack.github.io/xpm-liquid-ts) module, where
the substitutions are implemented.

### Variables

The LiquidJS syntax to include variables
uses double curly braces, like this: `{{variable}}`.

When substitutions occur within a build configuration, the `properties`
defined in the build configuration take precedence over `properties`
with the same name defined at the project level.

- `package.*` - the entire `package.json` parsed
- `properties.*` - user defined string properties
- `configuration.name` - the name of the current configuration
- `configuration.*` - the entire configuration parsed
- `env.*` - the Node.js process environment
- `os.*` - the Node.js `os` definitions
  - `os.EOL`
  - `os.arch` (like 'arm', 'arm64', 'ia32', 'x64')
  - `os.constants`
  - `os.cpus`
  - `os.endianness`
  - `os.homedir`
  - `os.hostname`
  - `os.platform` (like 'darwin', 'linux', 'win32')
  - `os.release`
  - `os.tmpdir`
  - `os.type`
  - `os.version` (available since Node 12)
- `path.*` definitions
  - `path.delimiter` (`;` for Windows, `:` for POSIX)
  - `path.sep` (`\` on Windows, `/` on POSIX)
  - `path.win32.delimiter` (`;`)
  - `path.win32.sep` (`\`)
  - `path.posix.delimiter` (`:`)
  - `path.posix.sep` (`/`)


Example:

```json title="Simple variable substitution"
"install": "xpm install --config {{configuration.name}}"
```

### Custom filters

Filters act like pipes processing strings. The syntax is similar to
the shell pipe syntax: `{{variable|filter}}`.

- `path_basename`
- `path_dirname`
- `path_normalize`
- `path_join`
- `path_relative`
- `path_posix_basename`
- `path_posix_dirname`
- `path_posix_normalize`
- `path_posix_join`
- `path_posix_relative`
- `path_win32_basename`
- `path_win32_dirname`
- `path_win32_normalize`
- `path_win32_join`
- `path_win32_relative`
- `util_format`
- `to_filename`
- `to_posix_filename`
- `to_win32_filename`

Example:

```json title="Multi-filter substitution"
"buildFolderRelativePath": "{{'build' | path_join: configuration.name | to_filename | downcase}}"
```

## The mandatory `xpack` definitions

To identify a project as an **xpm** package (xPack), it must have an `xpack`
property, even empty, in the `package.json` file.

```json title="Minimal empty xpack" {4}
{
  "name": "my-awesome-project",
  "version": "1.0.0",
  "xpack": {}
}
```

Although not mandatory, it is also recommended to add an `xpack` keyword;
this may help find the xPacks in the public repository by searching for this
keyword.

```json title="Recommended keyword" {5}
{
  "name": "my-awesome-project",
  "version": "1.0.0",
  "keywords": [
    "xpack",
    "..."
  ],
  "xpack": {}
}
```

### The `minimumXpmRequired` definition

To allow **xpm** to evolve with future incompatible versions, a mechanism
is used to identify the required `xpm` version for interpreting the current
definitions in `package.json`.

`minimumXpmRequired` has dual usage:

- it prevents using an old **xpm** with a newer `package.json`
- it allows a newer **xpm** to revert some functionality to match the
older minimum required **xpm**.

The mechanism is similar to that used by CMake; the policies are
documented in the separate [Policies](/docs/user/policies/) page.

### The `dependencies` definitions

The `dependencies` definitions is similar to the **npm** definition,
but lists the **xpm** source packages required to compile/link-time.

When a source pacakge is installed locally (without `--global`) into the
local project `xpacks` folder, all packages listed in its `xpack.dependencies`
are also installed into the same local `xpacks` folder,
recursively.

In other words, the list of source dependencies is linearised, and all
dependencies are installed at the same top level, as required by
compiled languages (like C/C++), to have all source libraries
compiled and available at link time.

:::info

The main difference compared to **npm** is the linearized list of source
dependencies.

**npm**, which is a JavaScript/TypeScript tool, uses a
different strategy that preserves the hierarchical structure of
dependencies, not suitable for compiled languages.

:::

When installing source packages into an **xpm** project, they are also added
to the `dependencies` list, in the extended format.

Example:

```json title="Extended format source dependency" {5-7}
  "xpack": {
    "minimumXpmRequired": "0.19.4",
    "dependencies": {
      "@micro-os-plus/micro-test-plus": {
        "specifier": "^3.1.2",
        "local": "link",
        "platforms": "all"
      }
    },
  }
```

For historical reasons, when editting `package.json` manually, it is
also possible to use the short form, similar to the syntax used by **npm**.

Example:

```json title="Traditional short form source dependency" {4}
  "xpack": {
    "minimumXpmRequired": "0.19.4",
    "dependencies": {
      "@micro-os-plus/micro-test-plus": "^3.1.2"
    },
  }
```

### The `devDependencies` definitions

The `devDependencies` definitions is similar to the **npm** definition,
but lists the **xpm** definitions required during the development
of the current package.

When the `xpm install` is invoked in a project folder,
all packages listed in `xpack.devDependencies` are also installed
in the local project `xpacks` folder, and symbolic links (or
forwarders/shims on windows) to all executables are created in
`xpacks/.bin`.

No recursive search is performed.

When installing binary packages into an **xpm** project, they are also added
to the `devDependencies` list, in the extended format.

Example:

```json title="Extended format development dependency" {5-7}
  "xpack": {
    "minimumXpmRequired": "0.19.4",
    "devDependencies": {
      "@xpack-dev-tools/cmake": {
        "specifier": "3.28.6-1.1",
        "local": "link",
        "platforms": "all"
      }
    }
  }
```

### The `binaries` definitions

To keep packages small, binary xPacks do not include the platform specific
binaries; instead they include only links
to the binary archives, and checksums to validate the downloads.

Example:

```json {10,14,40}
{
  "name": "@xpack-dev-tools/cmake",
  "version": "3.28.6-1.1",
  "description": "A binary xPack with the CMake executables",
  "...": "...",
  "xpack": {
    "minimumXpmRequired": "0.16.3",
    "binaries": {
      "destination": "./.content",
      "baseUrl": "https://github.com/xpack-dev-tools/cmake-xpack/releases/download/v3.28.6-1",
      "skip": 1,
      "platforms": {
        "darwin-arm64": {
          "fileName": "xpack-cmake-3.28.6-1-darwin-arm64.tar.gz",
          "sha256": "a2f4f7d4963a3ee41ed3ef80a6dfed1e161b0b33b519fe2c4f11f4d9d310c36e"
        },
        "darwin-x64": {
          "fileName": "xpack-cmake-3.28.6-1-darwin-x64.tar.gz",
          "sha256": "bafce78a57bab8c82268b32c0849ab875b437b90bed9bec83aad4c82af320103"
        },
        "linux-arm": {
          "fileName": "xpack-cmake-3.28.6-1-linux-arm.tar.gz",
          "sha256": "d73889f852b310f974e20246775eb16b272384dbf6fdc236583395af40bf7b54"
        },
        "linux-arm64": {
          "fileName": "xpack-cmake-3.28.6-1-linux-arm64.tar.gz",
          "sha256": "c80bd91b0e2b473d57b0ff30ea6ffc28480576946d6e69b65204f9d26dadfa52"
        },
        "linux-x64": {
          "fileName": "xpack-cmake-3.28.6-1-linux-x64.tar.gz",
          "sha256": "b05343bda081b988b2c91896133b56ce286a8269c8550d986cc2e71a243684e1"
        },
        "win32-x64": {
          "fileName": "xpack-cmake-3.28.6-1-win32-x64.zip",
          "sha256": "c1c07b1b51e0352e1fb1c9e6d87b743e975484df29f2a72c26d7385ad23fb679"
        }
      }
    },
    "bin": {
      "ccmake": "./.content/bin/ccmake",
      "cmake": "./.content/bin/cmake",
      "cpack": "./.content/bin/cpack",
      "ctest": "./.content/bin/ctest"
    }
  }
}
```

The `platforms` object define the location of platform specific archives.

<details>
<summary>The platforms names</summary>

The platform names are exactly those defined by Node.js, as
`process.platform` and `process.arch`:

- `darwin-arm64` - macOS arm64
- `darwin-x64` - macOS x64
- `linux-arm` - GNU/Linux Arm 32-bit (since 0.6.0)
- `linux-arm64` - GNU/Linux Arm 64-bit (since 0.6.0)
- `linux-x86` (deprecated)
- `linux-x32` (deprecated)
- `linux-ia32` - GNU/Linux x86 (since 0.6.0; deprecated)
- `linux-x64` - GNU/Linux x64
- `win32-x86` (deprecated)
- `win32-x32` (deprecated)
- `win32-ia32` - Windows x86 (since 0.6.0; deprecated)
- `win32-x64` - Windows x64

(`win32` is not very inspired, but we have to live with it.)

</details>

The files are downloaded from `<baseUrl>/<fileName>`. The common
use case is to have all files published in the same folder; in this case it is
enough to define `baseUrl` once. However it is also possible to
download files from different folders/servers, by defining it
for each platform.

The archives are unpacked in the `destination` folder, defined as relative
to the package root folder (usually `./.content`).

To allow the archives to be manually expanded, the build scripts add an
initial folder with the package name and version
(like `xpack-arm-none-eabi-gcc-13.3.1-1.1`).

To shorten the paths, **xpm** can skip this folder, or any number of initial
levels of folders in the archive, using the `skip` definition.

### The `bin` definitions

When installing a package with executables,
after the archive is unpacked, links to all executables defined
in the `bin` object are created in the `xpacks/.bin` folder.
On Windows, where soft links to files are problematic, `.cmd`
forwarders/shims are created.

:::tip

To accommodate for the `.cmd` stubs,
programs launching the executables should do this via an explicit
shell like `cmd.exe` or `PowerShell.exe`.

:::

### The `properties` definitions

The `properties` map allows to define string properties that can
be used as substitution variable in other definitions.

`properties` can be defined on top of other `properties`, and the LiquidJS
engine will be invoked repeatedly until all substitutions are performed.

When substitutions occur within a build configuration, the `properties`
defined in the build configuration take precedence over `properties`
with the same name defined at the project level.

Examples:

```json title="Project properties" {4}
{
  "xpack": {
    "properties": {
      "buildFolderRelativePath": "{{'build' | path_join: configuration.name | to_filename | downcase}}",
    }
  }
}
```

```json title="Build configuration properties" {6,12,13}
{
  "name": "@xpack-dev-tools/cmake",
  "version": "3.28.6-1.1",
  "xpack": {
    "properties": {
      "appLcName": "cmake",
    },
    "buildConfigurations": {
      "common-docker": {
        "hidden": true,
        "properties": {
          "containerName": "{{properties.appLcName}}-{{package.version}}-{{configuration.name}}",
          "force32": ""
        }
      }
    }
  }
}
```

### The `actions` definitions

**xpm** actions are an extended version of **npm** scripts, that
supports multiple lines and substitutions.

`actions` can be defined at project level, or at build configuration level.

When actions are invoked for a specific a build configuration, the `actions`
defined in the build configuration take precedence over `actions`
with the same name defined at the project level.

Example:

```json {9,22}
{
  "name": "@xpack-dev-tools/cmake",
  "version": "3.28.6-1.1",
  "xpack": {
    "properties": {
      "appLcName": "cmake",
    },
    "actions": {
      "install": [
        "npm install",
        "xpm install"
      ]
    },
    "buildConfigurations": {
      "common-docker": {
        "hidden": true,
        "properties": {
          "containerName": "{{properties.appLcName}}-{{package.version}}-{{configuration.name}}",
          "force32": ""
        },
        "actions": {
          "docker-remove": [
            "docker stop {{properties.containerName}}",
            "docker rm {{properties.containerName}}"
          ]
        }
      }
    }
  }
}
```

### The `buildConfigurations` definitions

During **development**, it is usual to build **separate debug and release
binaries**, with different configurations, like different preprocessor
macros, different compiler options, different optimisation levels, etc.

Extensive **testing** also requires building separate binaries, possible
targetted to **different architectures**, and using **different toolchains**,
even **different versions** of the same toolchain.

The build configurations address exactly this need, and allow to define
**multiple different actions to run different builds and/or tests**.

Build configurations can define their own `properties`, `actions`,
`definitions` and `devDefinition`
which take precedence over definitions with the same names defined at
the project level.

To avoid redundant definitions, build configurations can **inherit**
`properties`, `actions`, `definitions` and `devDefinition`
from one or more other build configurations,
and redefine some of them, as needed.

A build configuration can inherit from multiple other build configurations.
The `inherit` array defines the list inherited build configurations;
the common definitions are collected in the listed order, with later
entries overriding earlier ones.

Example:

```json {8,26,31,46,54}
{
  "xpack": {
    "buildConfigurations": {
      "common-dependencies": { "...": "..." },
      "common-actions": { "...": "..." },
      "common-actions-native": { "...": "..." },
      "common-docker": { "...": "..." },
      "darwin-x64": {
        "inherit": [
          "common-dependencies",
          "common-actions",
          "common-actions-native"
        ],
        "devDependencies": {
          "@xpack-dev-tools/clang": "16.0.6-1.1",
          "@xpack-dev-tools/realpath": "9.4.0-1.1",
          "@xpack-dev-tools/sed": "4.9.0-3.1"
        },
        "actions": {
          "build": "caffeinate {{properties.commandBashBuild}}",
          "build-development": "caffeinate {{properties.commandBashBuild}} --develop",
          "build-development-debug": "caffeinate {{properties.commandBashBuild}} --develop --debug",
          "build-development-tests-only": "caffeinate {{properties.commandBashBuild}} --develop --tests-only"
        }
      },
      "darwin-arm64": {
        "inherit": [
          "darwin-x64"
        ]
      },
      "linux-x64": {
        "inherit": [
          "common-dependencies",
          "common-actions",
          "common-actions-native",
          "common-docker"
        ],
        "devDependencies": {
          "@xpack-dev-tools/gcc": "13.2.0-2.1",
          "@xpack-dev-tools/patchelf": "0.18.0-1.1"
        },
        "properties": {
          "dockerImage": "ilegeul/ubuntu:amd64-18.04-xbb-v5.2.2"
        }
      },
      "linux-arm64": {
        "inherit": [
          "linux-x64"
        ],
        "properties": {
          "dockerImage": "ilegeul/ubuntu:arm64v8-18.04-xbb-v5.2.2"
        }
      },
      "linux-arm": {
        "inherit": [
          "linux-x64"
        ],
        "properties": {
          "dockerImage": "ilegeul/ubuntu:arm32v7-18.04-xbb-v5.2.2",
          "force32": "linux32"
        }
      }
    }
  }
}
```

The `"hidden": true` definition can be used by GUI tools
(like Visual Studio Code) to filter out
internal definition when rendering trees of action, for example.
